/**
 * generated by Xtext 2.19.0
 */
package es.us.isa.idl.generator;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import es.us.isa.idl.generator.ReservedWords;
import es.us.isa.idl.idl.ArithmeticDependency;
import es.us.isa.idl.idl.ConditionalDependency;
import es.us.isa.idl.idl.Dependency;
import es.us.isa.idl.idl.GeneralClause;
import es.us.isa.idl.idl.GeneralClauseContinuation;
import es.us.isa.idl.idl.GeneralPredefinedDependency;
import es.us.isa.idl.idl.GeneralPredicate;
import es.us.isa.idl.idl.GeneralTerm;
import es.us.isa.idl.idl.Operation;
import es.us.isa.idl.idl.OperationContinuation;
import es.us.isa.idl.idl.Param;
import es.us.isa.idl.idl.ParamValueRelation;
import es.us.isa.idl.idl.RelationalDependency;
import es.us.isa.idl.idl.impl.ArithmeticDependencyImpl;
import es.us.isa.idl.idl.impl.ConditionalDependencyImpl;
import es.us.isa.idl.idl.impl.GeneralPredefinedDependencyImpl;
import es.us.isa.idl.idl.impl.GeneralTermImpl;
import es.us.isa.idl.idl.impl.ParamImpl;
import es.us.isa.idl.idl.impl.RelationalDependencyImpl;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class IDLGenerator extends AbstractGenerator {
  private final String constraintsFileName = "base_constraints.mzn";
  
  private final String stringIntMappingFileName = "string_int_mapping.json";
  
  private String csp;
  
  private String fullCsp;
  
  private Integer stringToIntCounter;
  
  private Map<String, Integer> stringIntMapping = new HashMap<String, Integer>();
  
  private String folderPath = "./idl_aux_files";
  
  public String getFolderPath() {
    return this.folderPath;
  }
  
  public void setFolderPath(final String folderPath) {
    this.folderPath = folderPath;
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    try {
      this.stringIntMapping.clear();
      this.stringToIntCounter = Integer.valueOf(0);
      this.fullCsp = "constraint (";
      Iterable<Dependency> _iterable = IteratorExtensions.<Dependency>toIterable(Iterators.<Dependency>filter(resource.getAllContents(), Dependency.class));
      for (final Dependency dependency : _iterable) {
        {
          this.csp = "(";
          Class<? extends EObject> _class = dependency.getDep().getClass();
          boolean _equals = Objects.equal(_class, ConditionalDependencyImpl.class);
          if (_equals) {
            EObject _dep = dependency.getDep();
            this.writeConditionalDependency(((ConditionalDependency) _dep));
          } else {
            Class<? extends EObject> _class_1 = dependency.getDep().getClass();
            boolean _equals_1 = Objects.equal(_class_1, RelationalDependencyImpl.class);
            if (_equals_1) {
              EObject _dep_1 = dependency.getDep();
              this.writeRelationalDependency(((RelationalDependency) _dep_1), true);
            } else {
              Class<? extends EObject> _class_2 = dependency.getDep().getClass();
              boolean _equals_2 = Objects.equal(_class_2, ArithmeticDependencyImpl.class);
              if (_equals_2) {
                EObject _dep_2 = dependency.getDep();
                this.writeArithmeticDependency(((ArithmeticDependency) _dep_2), true);
              } else {
                Class<? extends EObject> _class_3 = dependency.getDep().getClass();
                boolean _equals_3 = Objects.equal(_class_3, GeneralPredefinedDependencyImpl.class);
                if (_equals_3) {
                  EObject _dep_3 = dependency.getDep();
                  this.writePredefinedDependency(((GeneralPredefinedDependency) _dep_3));
                } else {
                  throw new Exception(("The dependency must be a conditional, an " + 
                    "arithmetic, a relational or a predefined one"));
                }
              }
            }
          }
          String _csp = this.csp;
          this.csp = (_csp + ")\n/\\\n");
          String _fullCsp = this.fullCsp;
          this.fullCsp = (_fullCsp + this.csp);
        }
      }
      int _length = this.fullCsp.length();
      int _minus = (_length - 4);
      this.fullCsp = this.fullCsp.substring(0, _minus);
      String _fullCsp = this.fullCsp;
      this.fullCsp = (_fullCsp + ");");
      boolean _contains = this.fullCsp.contains("constrai);");
      if (_contains) {
        this.fullCsp = "";
      }
      File file = new File(((this.folderPath + "/") + this.constraintsFileName));
      file.delete();
      boolean _exists = file.exists();
      boolean _not = (!_exists);
      if (_not) {
        file.getParentFile().mkdirs();
        file.createNewFile();
      }
      FileWriter _fileWriter = new FileWriter(file, false);
      BufferedWriter out = new BufferedWriter(_fileWriter);
      out.append(this.fullCsp);
      out.flush();
      out.close();
      File mappingFile = new File(((this.folderPath + "/") + this.stringIntMappingFileName));
      mappingFile.delete();
      boolean _exists_1 = mappingFile.exists();
      boolean _not_1 = (!_exists_1);
      if (_not_1) {
        mappingFile.getParentFile().mkdirs();
        mappingFile.createNewFile();
      }
      FileWriter _fileWriter_1 = new FileWriter(mappingFile, false);
      BufferedWriter mappingOut = new BufferedWriter(_fileWriter_1);
      ObjectMapper mapper = new ObjectMapper();
      String json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(this.stringIntMapping);
      mappingOut.append(json);
      mappingOut.flush();
      mappingOut.close();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Remove and replace special characters from paramName
   */
  private String parseIDLParamName(final String paramName) {
    String parsedParamName = paramName.replaceAll("^\\[|\\]$", "").replaceAll("[\\.\\-\\/\\:\\[\\]]", "_");
    boolean _contains = ReservedWords.RESERVED_WORDS.contains(parsedParamName);
    if (_contains) {
      String _parsedParamName = parsedParamName;
      parsedParamName = (_parsedParamName + "_R");
    }
    return parsedParamName;
  }
  
  private Integer stringToInt(final String stringValue) {
    final Integer intMapping = this.stringIntMapping.get(stringValue);
    if ((intMapping != null)) {
      return intMapping;
    } else {
      this.stringIntMapping.put(stringValue, this.stringToIntCounter);
      return this.stringToIntCounter++;
    }
  }
  
  /**
   * Surround double with brackets if it's negative, and remove decimals (MiniZinc does not support floats)
   */
  private String parseDouble(final String doubleValue) {
    final String doubleWithoutDec = doubleValue.replaceAll("\\.\\d+", "");
    boolean _contains = doubleWithoutDec.contains("-");
    if (_contains) {
      return (("(" + doubleWithoutDec) + ")");
    }
    return doubleWithoutDec;
  }
  
  /**
   * Returns true if param is actually a ParamValueRelation. False if it is a Param
   */
  private boolean isParamValueRelation(final Param param) {
    return ((((param.getStringValues().size() != 0) || (param.getPatternString() != null)) || (param.getBooleanValue() != null)) || (param.getDoubleValue() != null));
  }
  
  private void writePredicate(final GeneralPredicate predicate) {
    try {
      this.writeClause(predicate.getFirstClause());
      GeneralClauseContinuation _clauseContinuation = predicate.getClauseContinuation();
      boolean _tripleNotEquals = (_clauseContinuation != null);
      if (_tripleNotEquals) {
        String _logicalOp = predicate.getClauseContinuation().getLogicalOp();
        boolean _equals = Objects.equal(_logicalOp, "AND");
        if (_equals) {
          String _csp = this.csp;
          this.csp = (_csp + " /\\ ");
        } else {
          String _logicalOp_1 = predicate.getClauseContinuation().getLogicalOp();
          boolean _equals_1 = Objects.equal(_logicalOp_1, "OR");
          if (_equals_1) {
            String _csp_1 = this.csp;
            this.csp = (_csp_1 + " \\/ ");
          } else {
            throw new Exception("The logical operator can only be AND or OR");
          }
        }
        this.writePredicate(predicate.getClauseContinuation().getAdditionalElements());
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void writeClause(final GeneralClause clause) {
    try {
      GeneralPredicate _predicate = clause.getPredicate();
      boolean _tripleNotEquals = (_predicate != null);
      if (_tripleNotEquals) {
        String _not = clause.getNot();
        boolean _tripleNotEquals_1 = (_not != null);
        if (_tripleNotEquals_1) {
          String _csp = this.csp;
          this.csp = (_csp + "(not ");
        }
        String _csp_1 = this.csp;
        this.csp = (_csp_1 + "(");
        this.writePredicate(clause.getPredicate());
        String _csp_2 = this.csp;
        this.csp = (_csp_2 + ")");
        String _not_1 = clause.getNot();
        boolean _tripleNotEquals_2 = (_not_1 != null);
        if (_tripleNotEquals_2) {
          String _csp_3 = this.csp;
          this.csp = (_csp_3 + ")");
        }
      }
      EObject _firstElement = clause.getFirstElement();
      boolean _tripleNotEquals_3 = (_firstElement != null);
      if (_tripleNotEquals_3) {
        Class<? extends EObject> _class = clause.getFirstElement().getClass();
        boolean _equals = Objects.equal(_class, GeneralTermImpl.class);
        if (_equals) {
          EObject _firstElement_1 = clause.getFirstElement();
          final GeneralTerm term = ((GeneralTerm) _firstElement_1);
          ParamValueRelation _param = term.getParam();
          final Param param = ((Param) _param);
          String _not_2 = term.getNot();
          boolean _tripleNotEquals_4 = (_not_2 != null);
          if (_tripleNotEquals_4) {
            String _csp_4 = this.csp;
            this.csp = (_csp_4 + "(not ");
          }
          String _csp_5 = this.csp;
          this.csp = (_csp_5 + "(");
          String _csp_6 = this.csp;
          String _parseIDLParamName = this.parseIDLParamName(param.getName());
          String _plus = (_parseIDLParamName + "Set==1");
          this.csp = (_csp_6 + _plus);
          boolean _isParamValueRelation = this.isParamValueRelation(param);
          if (_isParamValueRelation) {
            String _csp_7 = this.csp;
            this.csp = (_csp_7 + " /\\ ");
            String _booleanValue = param.getBooleanValue();
            boolean _tripleNotEquals_5 = (_booleanValue != null);
            if (_tripleNotEquals_5) {
              String _csp_8 = this.csp;
              String _parseIDLParamName_1 = this.parseIDLParamName(param.getName());
              String _plus_1 = (_parseIDLParamName_1 + "==");
              String _booleanValue_1 = param.getBooleanValue();
              String _plus_2 = (_plus_1 + _booleanValue_1);
              this.csp = (_csp_8 + _plus_2);
            } else {
              String _doubleValue = param.getDoubleValue();
              boolean _tripleNotEquals_6 = (_doubleValue != null);
              if (_tripleNotEquals_6) {
                String _csp_9 = this.csp;
                String _parseIDLParamName_2 = this.parseIDLParamName(param.getName());
                String _relationalOp = param.getRelationalOp();
                String _plus_3 = (_parseIDLParamName_2 + _relationalOp);
                String _parseDouble = this.parseDouble(param.getDoubleValue());
                String _plus_4 = (_plus_3 + _parseDouble);
                this.csp = (_csp_9 + _plus_4);
              } else {
                int _size = param.getStringValues().size();
                boolean _tripleNotEquals_7 = (_size != 0);
                if (_tripleNotEquals_7) {
                  String _csp_10 = this.csp;
                  this.csp = (_csp_10 + "(");
                  EList<String> _stringValues = param.getStringValues();
                  for (final String string : _stringValues) {
                    String _csp_11 = this.csp;
                    String _parseIDLParamName_3 = this.parseIDLParamName(param.getName());
                    String _plus_5 = (_parseIDLParamName_3 + "==");
                    Integer _stringToInt = this.stringToInt(string);
                    String _plus_6 = (_plus_5 + _stringToInt);
                    String _plus_7 = (_plus_6 + " \\/ ");
                    this.csp = (_csp_11 + _plus_7);
                  }
                  int _length = this.csp.length();
                  int _minus = (_length - 4);
                  this.csp = this.csp.substring(0, _minus);
                  String _csp_12 = this.csp;
                  this.csp = (_csp_12 + ")");
                } else {
                  String _patternString = param.getPatternString();
                  boolean _tripleNotEquals_8 = (_patternString != null);
                  if (_tripleNotEquals_8) {
                    String _csp_13 = this.csp;
                    this.csp = (_csp_13 + "true");
                  }
                }
              }
            }
          }
          String _csp_14 = this.csp;
          this.csp = (_csp_14 + ")");
          String _not_3 = term.getNot();
          boolean _tripleNotEquals_9 = (_not_3 != null);
          if (_tripleNotEquals_9) {
            String _csp_15 = this.csp;
            this.csp = (_csp_15 + ")");
          }
        } else {
          Class<? extends EObject> _class_1 = clause.getFirstElement().getClass();
          boolean _equals_1 = Objects.equal(_class_1, RelationalDependencyImpl.class);
          if (_equals_1) {
            EObject _firstElement_2 = clause.getFirstElement();
            this.writeRelationalDependency(((RelationalDependency) _firstElement_2), false);
          } else {
            Class<? extends EObject> _class_2 = clause.getFirstElement().getClass();
            boolean _equals_2 = Objects.equal(_class_2, ArithmeticDependencyImpl.class);
            if (_equals_2) {
              EObject _firstElement_3 = clause.getFirstElement();
              this.writeArithmeticDependency(((ArithmeticDependency) _firstElement_3), false);
            } else {
              Class<? extends EObject> _class_3 = clause.getFirstElement().getClass();
              boolean _equals_3 = Objects.equal(_class_3, GeneralPredefinedDependencyImpl.class);
              if (_equals_3) {
                EObject _firstElement_4 = clause.getFirstElement();
                this.writePredefinedDependency(((GeneralPredefinedDependency) _firstElement_4));
              } else {
                throw new Exception(("The first element of a clause must be a term, an " + 
                  "arithmetic dependency, a relational dependency or a predefined dependency"));
              }
            }
          }
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void writeConditionalDependency(final ConditionalDependency dep) {
    String _csp = this.csp;
    this.csp = (_csp + "(");
    this.writePredicate(dep.getCondition());
    String _csp_1 = this.csp;
    this.csp = (_csp_1 + ") -> (");
    this.writePredicate(dep.getConsequence());
    String _csp_2 = this.csp;
    this.csp = (_csp_2 + ")");
  }
  
  private void writeRelationalDependency(final RelationalDependency dep, final boolean alone) {
    if (alone) {
      String _csp = this.csp;
      String _parseIDLParamName = this.parseIDLParamName(dep.getParam1().getName());
      String _plus = ("((" + _parseIDLParamName);
      String _plus_1 = (_plus + "Set==1 /\\ ");
      String _parseIDLParamName_1 = this.parseIDLParamName(dep.getParam2().getName());
      String _plus_2 = (_plus_1 + _parseIDLParamName_1);
      String _plus_3 = (_plus_2 + "Set==1) -> (");
      String _parseIDLParamName_2 = this.parseIDLParamName(dep.getParam1().getName());
      String _plus_4 = (_plus_3 + _parseIDLParamName_2);
      String _relationalOp = dep.getRelationalOp();
      String _plus_5 = (_plus_4 + _relationalOp);
      String _parseIDLParamName_3 = this.parseIDLParamName(dep.getParam2().getName());
      String _plus_6 = (_plus_5 + _parseIDLParamName_3);
      String _plus_7 = (_plus_6 + "))");
      this.csp = (_csp + _plus_7);
    } else {
      String _csp_1 = this.csp;
      String _parseIDLParamName_4 = this.parseIDLParamName(dep.getParam1().getName());
      String _plus_8 = ("(" + _parseIDLParamName_4);
      String _plus_9 = (_plus_8 + "Set==1 /\\ ");
      String _parseIDLParamName_5 = this.parseIDLParamName(dep.getParam2().getName());
      String _plus_10 = (_plus_9 + _parseIDLParamName_5);
      String _plus_11 = (_plus_10 + "Set==1 /\\ ");
      String _parseIDLParamName_6 = this.parseIDLParamName(dep.getParam1().getName());
      String _plus_12 = (_plus_11 + _parseIDLParamName_6);
      String _relationalOp_1 = dep.getRelationalOp();
      String _plus_13 = (_plus_12 + _relationalOp_1);
      String _parseIDLParamName_7 = this.parseIDLParamName(dep.getParam2().getName());
      String _plus_14 = (_plus_13 + _parseIDLParamName_7);
      String _plus_15 = (_plus_14 + ")");
      this.csp = (_csp_1 + _plus_15);
    }
  }
  
  private void writeArithmeticDependency(final ArithmeticDependency dep, final boolean alone) {
    String _csp = this.csp;
    this.csp = (_csp + "((");
    Iterable<Param> _iterable = IteratorExtensions.<Param>toIterable(Iterators.<Param>filter(dep.eAllContents(), Param.class));
    for (final Param param : _iterable) {
      String _csp_1 = this.csp;
      String _parseIDLParamName = this.parseIDLParamName(param.getName());
      String _plus = (_parseIDLParamName + "Set==1 /\\ ");
      this.csp = (_csp_1 + _plus);
    }
    if (alone) {
      int _length = this.csp.length();
      int _minus = (_length - 4);
      this.csp = this.csp.substring(0, _minus);
      String _csp_2 = this.csp;
      this.csp = (_csp_2 + ") -> (");
    }
    this.writeOperation(dep.getOperation());
    String _csp_3 = this.csp;
    String _relationalOp = dep.getRelationalOp();
    this.csp = (_csp_3 + _relationalOp);
    String _csp_4 = this.csp;
    String _parseDouble = this.parseDouble(dep.getResult());
    this.csp = (_csp_4 + _parseDouble);
    String _csp_5 = this.csp;
    this.csp = (_csp_5 + "))");
  }
  
  private void writeOperation(final Operation operation) {
    String _openingParenthesis = operation.getOpeningParenthesis();
    boolean _tripleEquals = (_openingParenthesis == null);
    if (_tripleEquals) {
      String _csp = this.csp;
      String _name = operation.getFirstParam().getName();
      this.csp = (_csp + _name);
      this.writeOperationContinuation(operation.getOperationContinuation());
    } else {
      String _csp_1 = this.csp;
      this.csp = (_csp_1 + "(");
      this.writeOperation(operation.getOperation());
      String _csp_2 = this.csp;
      this.csp = (_csp_2 + ")");
      OperationContinuation _operationContinuation = operation.getOperationContinuation();
      boolean _tripleNotEquals = (_operationContinuation != null);
      if (_tripleNotEquals) {
        this.writeOperationContinuation(operation.getOperationContinuation());
      }
    }
  }
  
  private void writeOperationContinuation(final OperationContinuation opCont) {
    String _csp = this.csp;
    String _arithOp = opCont.getArithOp();
    this.csp = (_csp + _arithOp);
    Class<? extends EObject> _class = opCont.getAdditionalParams().getClass();
    boolean _equals = Objects.equal(_class, ParamImpl.class);
    if (_equals) {
      String _csp_1 = this.csp;
      EObject _additionalParams = opCont.getAdditionalParams();
      String _name = ((Param) _additionalParams).getName();
      this.csp = (_csp_1 + _name);
    } else {
      EObject _additionalParams_1 = opCont.getAdditionalParams();
      this.writeOperation(((Operation) _additionalParams_1));
    }
  }
  
  private void writePredefinedDependency(final GeneralPredefinedDependency dep) {
    try {
      String _not = dep.getNot();
      boolean _tripleNotEquals = (_not != null);
      if (_tripleNotEquals) {
        String _csp = this.csp;
        this.csp = (_csp + "(not ");
      }
      String _csp_1 = this.csp;
      this.csp = (_csp_1 + "(");
      EList<GeneralPredicate> _predefDepElements = dep.getPredefDepElements();
      for (final GeneralPredicate depElement : _predefDepElements) {
        {
          String _csp_2 = this.csp;
          this.csp = (_csp_2 + "(");
          String _predefDepType = dep.getPredefDepType();
          if (_predefDepType != null) {
            switch (_predefDepType) {
              case "Or":
                this.writePredicate(depElement);
                String _csp_3 = this.csp;
                this.csp = (_csp_3 + ") \\/ ");
                break;
              case "OnlyOne":
                this.writeZeroOrOneOnlyOneElement(depElement, ((GeneralPredicate[])Conversions.unwrapArray(dep.getPredefDepElements(), GeneralPredicate.class)));
                String _csp_4 = this.csp;
                this.csp = (_csp_4 + ") /\\ ");
                break;
              case "AllOrNone":
                this.writeAllOrNoneElement(depElement, ((GeneralPredicate[])Conversions.unwrapArray(dep.getPredefDepElements(), GeneralPredicate.class)));
                String _csp_5 = this.csp;
                this.csp = (_csp_5 + ") /\\ ");
                break;
              case "ZeroOrOne":
                this.writeZeroOrOneOnlyOneElement(depElement, ((GeneralPredicate[])Conversions.unwrapArray(dep.getPredefDepElements(), GeneralPredicate.class)));
                String _csp_6 = this.csp;
                this.csp = (_csp_6 + ") /\\ ");
                break;
              default:
                throw new Exception(("The predefined dependency can only be \'Or\', " + 
                  "\'OnlyOne\', \'AllOrNone\' or \'ZeroOrOne\'"));
            }
          } else {
            throw new Exception(("The predefined dependency can only be \'Or\', " + 
              "\'OnlyOne\', \'AllOrNone\' or \'ZeroOrOne\'"));
          }
        }
      }
      boolean _equals = dep.getPredefDepType().equals("OnlyOne");
      if (_equals) {
        String _csp_2 = this.csp;
        this.csp = (_csp_2 + "(");
        EList<GeneralPredicate> _predefDepElements_1 = dep.getPredefDepElements();
        for (final GeneralPredicate depElement_1 : _predefDepElements_1) {
          {
            String _csp_3 = this.csp;
            this.csp = (_csp_3 + "(");
            this.writePredicate(depElement_1);
            String _csp_4 = this.csp;
            this.csp = (_csp_4 + ") \\/ ");
          }
        }
        int _length = this.csp.length();
        int _minus = (_length - 4);
        this.csp = this.csp.substring(0, _minus);
        String _csp_3 = this.csp;
        this.csp = (_csp_3 + ")");
      } else {
        int _length_1 = this.csp.length();
        int _minus_1 = (_length_1 - 4);
        this.csp = this.csp.substring(0, _minus_1);
      }
      String _csp_4 = this.csp;
      this.csp = (_csp_4 + ")");
      String _not_1 = dep.getNot();
      boolean _tripleNotEquals_1 = (_not_1 != null);
      if (_tripleNotEquals_1) {
        String _csp_5 = this.csp;
        this.csp = (_csp_5 + ")");
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void writeZeroOrOneOnlyOneElement(final GeneralPredicate element, final GeneralPredicate[] allElements) {
    this.writeZeroOrOneAllOrNoneElement(element, allElements, false, true);
  }
  
  private void writeAllOrNoneElement(final GeneralPredicate element, final GeneralPredicate[] allElements) {
    this.writeZeroOrOneAllOrNoneElement(element, allElements, false, false);
    String _csp = this.csp;
    this.csp = (_csp + ") /\\ (");
    this.writeZeroOrOneAllOrNoneElement(element, allElements, true, true);
  }
  
  private void writeZeroOrOneAllOrNoneElement(final GeneralPredicate element, final GeneralPredicate[] allElements, final boolean negateElement, final boolean negateRemainingElements) {
    if (negateElement) {
      String _csp = this.csp;
      this.csp = (_csp + "(not (");
      this.writePredicate(element);
      String _csp_1 = this.csp;
      this.csp = (_csp_1 + ")) -> (");
    } else {
      String _csp_2 = this.csp;
      this.csp = (_csp_2 + "(");
      this.writePredicate(element);
      String _csp_3 = this.csp;
      this.csp = (_csp_3 + ") -> (");
    }
    for (final GeneralPredicate remainingElement : allElements) {
      boolean _equals = remainingElement.equals(element);
      boolean _not = (!_equals);
      if (_not) {
        if (negateRemainingElements) {
          String _csp_4 = this.csp;
          this.csp = (_csp_4 + "(not (");
          this.writePredicate(remainingElement);
          String _csp_5 = this.csp;
          this.csp = (_csp_5 + ")) /\\ ");
        } else {
          String _csp_6 = this.csp;
          this.csp = (_csp_6 + "(");
          this.writePredicate(remainingElement);
          String _csp_7 = this.csp;
          this.csp = (_csp_7 + ") /\\ ");
        }
      }
    }
    int _length = this.csp.length();
    int _minus = (_length - 4);
    this.csp = this.csp.substring(0, _minus);
    String _csp_8 = this.csp;
    this.csp = (_csp_8 + ")");
  }
}
