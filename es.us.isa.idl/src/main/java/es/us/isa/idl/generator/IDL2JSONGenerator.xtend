/*
 * generated by Xtext 2.19.0
 */
package es.us.isa.idl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import java.io.File
import java.util.Map
import java.util.HashMap
import java.io.BufferedWriter
import java.io.FileWriter
import com.fasterxml.jackson.databind.ObjectMapper

import static es.us.isa.idl.generator.ReservedWords.RESERVED_WORDS;

import es.us.isa.idl.idl.GeneralClause
import es.us.isa.idl.idl.GeneralPredefinedDependency
import es.us.isa.idl.idl.Dependency;
import es.us.isa.idl.idl.ConditionalDependency;
import es.us.isa.idl.idl.impl.ConditionalDependencyImpl
import es.us.isa.idl.idl.impl.GeneralPredefinedDependencyImpl
import es.us.isa.idl.idl.impl.ArithmeticDependencyImpl
import es.us.isa.idl.idl.ArithmeticDependency
import es.us.isa.idl.idl.Operation
import es.us.isa.idl.idl.Param
import es.us.isa.idl.idl.impl.ParamImpl
import es.us.isa.idl.idl.OperationContinuation
import es.us.isa.idl.idl.impl.RelationalDependencyImpl
import es.us.isa.idl.idl.RelationalDependency
import es.us.isa.idl.idl.impl.GeneralTermImpl
import es.us.isa.idl.idl.GeneralTerm
import es.us.isa.idl.idl.GeneralPredicate
import java.util.List
import java.util.ArrayList
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import com.google.gson.JsonParser
import com.google.gson.JsonElement

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class IDL2JSONGenerator extends AbstractGenerator {

	val String stringIntMappingFileName = "string_int_mapping.json"
	val String idljsonContentName = "idl.json"
	var Integer stringToIntCounter
	var Map<String, Integer> stringIntMapping = new HashMap
	var String jsonContent;
	
	var String folderPath = "./idl_aux_files"
	
	def String getFolderPath() {
		return this.folderPath
	}
	
	def void setFolderPath(String folderPath) {
		this.folderPath = folderPath
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		stringIntMapping.clear
		stringToIntCounter = 0
		jsonContent = '{\n'+'"terms":[\n'
		val dependencyNumber = resource.allContents.filter(Dependency).size
		var i = 0
		
		for (dependency: resource.allContents.filter(Dependency).toIterable) {
			i = i + 1 
			jsonContent+='{\n'
			if (dependency.dep.class == typeof(ConditionalDependencyImpl)) {
				writeConditionalDependency(dependency.dep as ConditionalDependency)
			} else if (dependency.dep.class == typeof(RelationalDependencyImpl)) {
				writeRelationalDependency(dependency.dep as RelationalDependency, true)
			} else if (dependency.dep.class == typeof(ArithmeticDependencyImpl)) {
				writeArithmeticDependency(dependency.dep as ArithmeticDependency, true)
			} else if (dependency.dep.class == typeof(GeneralPredefinedDependencyImpl)) {
				writePredefinedDependency(dependency.dep as GeneralPredefinedDependency)
			} else {
				throw new Exception("The dependency must be a conditional, an " + 
					"arithmetic, a relational or a predefined one")
			}
			if(i==dependencyNumber){
				jsonContent+='}\n'
			}else{
				jsonContent+='},\n'
			}
			
		}
		jsonContent+=']\n}\n'
		
		// Export string-int mapping to JSON
		var mappingFile = new File(folderPath + "/" + stringIntMappingFileName)
		mappingFile.delete
		if (!mappingFile.exists) {
		  mappingFile.parentFile.mkdirs
		  mappingFile.createNewFile
		}
        var BufferedWriter mappingOut = new BufferedWriter(new FileWriter(mappingFile, false))
        
		var ObjectMapper mapper = new ObjectMapper
		var String json = mapper.writerWithDefaultPrettyPrinter.writeValueAsString(stringIntMapping)
		
        mappingOut.append(json)
        mappingOut.flush
        mappingOut.close
        
		// Export constraints to json File
		var json_file = new File(folderPath + "/" + idljsonContentName)
		json_file.delete
		if (!json_file.exists) {
		  json_file.parentFile.mkdirs
		  json_file.createNewFile
		}
		var BufferedWriter jsonOut = new BufferedWriter(new FileWriter(json_file, false))

		
		var Gson gson = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();
		var JsonParser jp = new JsonParser();
		var JsonElement je = jp.parse(jsonContent);
		jsonContent = gson.toJson(je);
				
		jsonOut.append(jsonContent)
		jsonOut.flush
		jsonOut.close
	}
	
	
	/**
	 * Remove and replace special characters from paramName
	 */
	def private String parseIDLParamName(String paramName) {
		var String parsedParamName = paramName.replaceAll("^\\[|\\]$", "").replaceAll("[\\.\\-\\/\\:\\[\\]]", "_")
		if (RESERVED_WORDS.contains(parsedParamName))
			parsedParamName += "_R"
		return parsedParamName
	}

	def private Integer stringToInt(String stringValue) {
		val Integer intMapping = stringIntMapping.get(stringValue)
		if (intMapping !== null) {
			return intMapping
		} else {
			stringIntMapping.put(stringValue, stringToIntCounter)
			return stringToIntCounter++
		}
	}
	
	
	/**
	 * Surround double with brackets if it's negative, and remove decimals (MiniZinc does not support floats)
	 */
	def private String parseDouble(String doubleValue) {
		val doubleWithoutDec = doubleValue.replaceAll("\\.\\d+", "")
		if (doubleWithoutDec.contains('-'))
			return ('(' + doubleWithoutDec + ')')
		return doubleWithoutDec
	}
	
	/**
	 * Returns true if param is actually a ParamValueRelation. False if it is a Param
	 */
	def private boolean isParamValueRelation(Param param) {
		return param.stringValues.size !== 0 || param.patternString !== null || param.booleanValue !== null || param.doubleValue !== null
	}
	

	
	
	def private void writePredicate(GeneralPredicate predicate) {
		var List<GeneralPredicate> andList = new ArrayList
		var List<GeneralPredicate> orList = new ArrayList
		andList.add(predicate)
		orList.add(predicate)
		writePredicate(predicate, andList, orList) 
	}
	
	//TODO Metodo auxiliar, tengo que pasar la lista para iterar mejor
	def private void writePredicate(GeneralPredicate predicate, List<GeneralPredicate> andList, List<GeneralPredicate> orList) {
		var Boolean negated = false
		if (predicate.clauseContinuation !== null) {
			if (predicate.clauseContinuation.logicalOp == "AND") {
					var newPredicate = predicate.clauseContinuation.additionalElements;
					andList.add(newPredicate)
					writePredicate(newPredicate, andList, orList)
				}else if (predicate.clauseContinuation.logicalOp == "OR") {
					var newPredicate = predicate.clauseContinuation.additionalElements;
					orList.add(newPredicate)
					writePredicate(newPredicate, andList, orList)
				}
		}else{
			if(predicate.firstClause.not!==null){
				negated=true
			}
			if(andList.size()== 1 && orList.size()==1){
				writeClause(predicate.firstClause)
			}else if(andList.size() > 1){
				jsonContent+='  "and":{\n'+ '"terms":[\n'
				for (term : andList) {
					jsonContent+='{\n'
					writeClause(term.firstClause)
					jsonContent+='}'
					if(andList.indexOf(term)!=andList.size-1){
						jsonContent+=','
					}
					jsonContent+='\n'
				}
				jsonContent+='],\n'
				jsonContent+='"negated":'+negated+"\n"
				jsonContent+='}\n'
			}else if(orList.size() > 1){
				jsonContent+='"or":\n'+'{"terms":[\n'
				for (term : orList) {
					jsonContent+='{\n'
					writeClause(term.firstClause)
					jsonContent+='}'
					if(orList.indexOf(term)!=orList.size-1){
						jsonContent+=','
					}
					jsonContent+='\n'
					
				}
				jsonContent+='],\n'
				jsonContent+='"negated":'+negated+"\n "
				jsonContent+='}\n'
			}
			
		}
	}
	
	
	def private void writeClause(GeneralClause clause) {
		var Boolean negated = false;
		if (clause.predicate !== null) {
			if (clause.not !== null)
				negated = true
			writePredicate(clause.predicate)
		}
		
		// Solve firstElement, which can be a term, arithmetic dep, relational dep or predefined dep
		if (clause.firstElement !== null) {
			if (clause.firstElement.class == typeof(GeneralTermImpl)) { // param or param assignment
				val GeneralTerm term = (clause.firstElement as GeneralTerm)
				val Param param = (term.param as Param)
				
				if (term.not !== null){
					negated = true
				}
				
				jsonContent +='"parameter":"' + parseIDLParamName(param.name) + '",\n'
				jsonContent +='"presence":' + "true,\n"
				jsonContent +='"negated":' + negated
				
				if (isParamValueRelation(param)) {
					if (param.booleanValue !== null) {
						jsonContent += ',\n'+'"relation": "=="'+ ',\n'
						jsonContent += '"value":'+param.booleanValue
					} else if (param.doubleValue !== null) {
						jsonContent+=',\n'+'"relation":"'+param.relationalOp +'",\n'
						jsonContent+='"double":'+parseDouble(param.doubleValue)
					} else if (param.stringValues.size !== 0) {
						for (string: param.stringValues) {
						jsonContent += ',\n'+'"relation": "=="'+ ',\n'
						jsonContent +='"value":"'+stringToInt(string)+'"\n'
						}
					}
				}
			} else if(clause.firstElement.class == typeof(RelationalDependencyImpl)) {
				writeRelationalDependency(clause.firstElement as RelationalDependency, false)
			} else if(clause.firstElement.class == typeof(ArithmeticDependencyImpl)) {
				writeArithmeticDependency(clause.firstElement as ArithmeticDependency, false)
			} else if(clause.firstElement.class == typeof(GeneralPredefinedDependencyImpl)) {
				writePredefinedDependency(clause.firstElement as GeneralPredefinedDependency)
			} else {
				throw new Exception("The first element of a clause must be a term, an " + 
					"arithmetic dependency, a relational dependency or a predefined dependency")
			}
			jsonContent += '\n'
		}
	}
	
	
	def private void writeConditionalDependency(ConditionalDependency dep) {
		var Boolean negated = false
		jsonContent +='"IfThenDepedency":\n' + '{"terms" : [\n'
		jsonContent+='{\n'
		writePredicate(dep.condition)
		jsonContent+='},\n'
		jsonContent+='{\n'
		writePredicate(dep.consequence)
		jsonContent+='}\n'
		jsonContent +=']}'
	}
	

	def private void writeRelationalDependency(RelationalDependency dep, boolean alone) {
		jsonContent+='"relationalDependency": {\n'
		jsonContent+='"relation": "'+dep.relationalOp+'",\n'
		jsonContent+='"firstTerm": "'+ parseIDLParamName(dep.param1.name) +'",\n'
		jsonContent+='"secondTerm": "'+parseIDLParamName(dep.param2.name)+'"\n'
		jsonContent+='}'
	}
	

	def private void writeArithmeticDependency(ArithmeticDependency dep, boolean alone) {

		jsonContent+='"arithmeticDependency": {\n'
		jsonContent+='"relation": "'+dep.relationalOp+'",\n'
		jsonContent+='"result": "'+ parseDouble(dep.result)+'",\n'
		jsonContent+='"operation": [\n'
		writeOperation(dep.operation)
		jsonContent+=']\n'
		jsonContent+='}'
	}
	
	
	
	def private void writeOperation(Operation operation) {
		if (operation.openingParenthesis === null) { // Alternative 1 of Operation
			jsonContent+='{\n'+'"parameter":"'+operation.firstParam.name+'"\n'+'},\n'
			writeOperationContinuation(operation.operationContinuation)
			
		} else { // Alternative 2 of Operation
			jsonContent+='{\n'+'"parenthesis":[\n'
			writeOperation(operation.operation)
			jsonContent+=']}'
			if (operation.operationContinuation !== null) {
				jsonContent+=',\n'
				writeOperationContinuation(operation.operationContinuation)
			}
			
		}
	}
	
	
	def private void writeOperationContinuation(OperationContinuation opCont) {
		jsonContent+='{\n'+'"operation":"'+opCont.arithOp+'"\n'+'},\n'
		if (opCont.additionalParams.class == typeof(ParamImpl)) {
			jsonContent+='{\n'+'"parameter":"'+(opCont.additionalParams as Param).name+'"\n'+'}\n'
		} else {
			writeOperation(opCont.additionalParams as Operation)
		}
	}
	
	def private void writePredefinedDependency(GeneralPredefinedDependency dep) {
		if (dep.not !== null)
			jsonContent+='"negated": true,\n'
		switch dep.predefDepType {
			case "Or": {
				jsonContent+='"OrDepdencny":'
			} case "OnlyOne": {
				jsonContent+='"OnlyOne":'
			} case "AllOrNone": {
				jsonContent+='"AllOrNone":'
			} case "ZeroOrOne": {
				jsonContent+='"ZeroOrOne":'
			} default:
				throw new Exception("The predefined dependency can only be 'Or', " + 
					"'OnlyOne', 'AllOrNone' or 'ZeroOrOne'")
		}
		
		jsonContent += '{\n'+'  "terms":[\n'
		
		for (depElement: dep.predefDepElements) {
			jsonContent+='{\n'
			writePredicate(depElement)
			if(dep.predefDepElements.indexOf(depElement)==dep.predefDepElements.size-1)
				jsonContent+='}\n'
			else
				jsonContent+='},\n'

		}
		jsonContent+=']}'

	}
		
	def private void writeZeroOrOneOnlyOneElement(GeneralPredicate element, GeneralPredicate[] allElements) {
		writeZeroOrOneAllOrNoneElement(element, allElements, false, true)
	}
	
	def private void writeAllOrNoneElement(GeneralPredicate element, GeneralPredicate[] allElements) {
		writeZeroOrOneAllOrNoneElement(element, allElements, false, false)
		writeZeroOrOneAllOrNoneElement(element, allElements, true, true)
	}
	
	def private void writeZeroOrOneAllOrNoneElement(GeneralPredicate element, GeneralPredicate[] allElements, boolean negateElement, boolean negateRemainingElements) {
		if (negateElement) { // For AllOrNone dependencies
			writePredicate(element)
		} else { // For ZeroOrOne, AllOrNone and OnlyOne dependencies
			writePredicate(element)
		}
		for (remainingElement: allElements) {
			if (!remainingElement.equals(element)) { // Include remaining elements in the consequence
				if (negateRemainingElements) { // For ZeroOrOne dependencies
					writePredicate(remainingElement)
				} else { // For ZeroOrOne, AllOrNone and OnlyOne dependencies
					writePredicate(remainingElement)
				}
			}
		}
	}
	
	
}

